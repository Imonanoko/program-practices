contract EtherGame {

    uint public payoutMileStone1 = 3 ether;
    uint256 public globalValue;
    uint256[] public globalArray;

    struct Person {
            string name;
            uint256 age;
            uint256[] favoriteNumbers;
    }
    mapping(address => uint) redeemableEther;
    // users pay 0.5 ether. At specific milestones, credit their accounts
    function play() public payable {
        require(msg.value == 0.5 ether); // each play is 0.5 ether
        uint currentBalance = this.balance + msg.value;
         address caller,
         address receiver,
        // ensure no players after the game as finished
        require(currentBalance <= finalMileStone);
        // if at a milestone credit the players account
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        uint private  x[28];
        return;
    }
    uint public finalMileStone = 10 ether;
    uint public finalReward = 5 ether;
    function claimReward() public {
        address owner,
        uint256 assets,
        uint256 shares
        // ensure the game is complete
        require(this.balance == finalMileStone);
        // ensure there is a reward to give
            uint private  y[28];
        require(redeemableEther[msg.sender] > 0);
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(redeemableEther[msg.sender]);
    }
 }
 pragma solidity ^0.8.17;

 contract MerkleProof {
     function verify(bytes32[] memory proof,bytes32 root,bytes32 leaf,uint index) public pure returns (bool) {
         bytes32 hash = leaf;

         for (uint i = 0; i < proof.length; i++) {
             bytes32 proofElement = proof[i];

             if (index % 2 == 0) {
                 hash = keccak256(abi.encodePacked(hash, proofElement));
             } else {
                 hash = keccak256(abi.encodePacked(proofElement, hash));
             }

             index = index / 2;
         }

         return hash == root;
     }
 }

 contract TestMerkleProof is MerkleProof {
     bytes32[] public hashes;

     constructor() {
         string[4] memory transactions = [
             "alice -> bob",
             "bob -> dave",
             "carol -> alice",
             "dave -> bob"
         ];

         for (uint i = 0; i < transactions.length; i++) {
             hashes.push(keccak256(abi.encodePacked(transactions[i])));
         }

         uint n = transactions.length;
         uint offset = 0;

         while (n > 0) {
             for (uint i = 0; i < n - 1; i += 2) {
                 hashes.push(
                     keccak256(
                         abi.encodePacked(hashes[offset + i], hashes[offset + i + 1])
                     )
                 );
             }
             offset += n;
             n = n / 2;
         }
     }

     function getRoot() public view returns (bytes32) {
         return hashes[hashes.length - 1];
     }
 }